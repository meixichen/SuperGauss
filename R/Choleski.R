#' @name Choleski
#' @aliases cholXZ cholZX
#' @title Toeplitz variance matrix Choleski decomposition
#' @description
#' Compute Choleski decomposition and multiply by another matrix, or solve Choleski system of equations.
#' @param X size \code{N x p} matrix of observations
#' @param Z size \code{N x p} matrix of residuals
#' @param acf length \code{N} vector, autocorrelation of Toeplitz matrix
#' @details Both of the two functions are done with Durbin-Levinson algorithm.
#' \itemize{
#' \item \code{cholZX}: computes the Choleski decomposition of Toeplitz matrix generated by \code{acf} and multiplies arbitary matrix: X = chol(toeplitz(acf))' * Z.
#' \item \code{cholXZ}: computes the inversion of Choleski decomposition of Toeplitz matrix generated by \code{acf} and multiplies arbitary matrix: Z = solve(chol(toeplitz(acf)), X).
#' }
#' @return Size \code{N x p} matrix.
#' @rdname Choleski
#' @examples
#' N <- 30
#' p <- 4
#' Mat <- matrix(rnorm(N * p), N, p)
#' acf <- exp(-(1:N - 1))
#' cholZX(Z = Mat, acf = acf)
#' cholXZ(X = Mat, acf = acf)
#' @export
cholZX <- function(Z, acf) {
  n <- length(acf)
  Z <- as.matrix(Z)
  if(nrow(Z) != n) stop("Z and acf have incompatible dimensions.")
  DurbinLevinson_ZX(Z = Z, acf = acf)
}

#' @rdname Choleski
#' @export
cholXZ <- function(X, acf) {
  n <- length(acf)
  X <- as.matrix(X)
  if(nrow(X) != n) stop("X and acf have incompatible dimensions.")
  DurbinLevinson_XZ(X = X, acf = acf)
}

