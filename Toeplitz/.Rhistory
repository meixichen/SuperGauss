p.iter <- array(NA, dim = c(K,nsamples))
I.iter <- array(NA, dim = c(n,nsamples))
if(loglik) ll.iter <- rep(NA, nsamples)
# allocate + initialize current values
if(!missing(I0)) {
I <- I0
} else {
I <- sample(1:K, size = n, replace = TRUE, prob = rep(1,K))
}
p <- table(I, dnn = NULL)/n
mu <- sapply(1:K, function(ii) colMeans(x[I == ii,]))
V <- vapply(1:K, function(ii) var(x[I == ii,]), matrix(0, d, d))
densK <- matrix(NA, K, n) # for density evaluation of each component
if(debug) browser()
for(smp in (-burn+1):nsamples) {
nk <- table(c(I,1:K), dnn = NULL)-1 # how many observations per component
# update mu
for(ii in 1:K) {
# don't update component if there are no observations
if(nk[ii] > 0) {
if(nk[ii] > 1) xbar <- colMeans(x[I == ii,]) else xbar <- x[I == ii,]
if(all(Omega[,,ii]==0)) {
B <- matrix(0, d, d)
} else {
B <- (V[,,ii]/nk[ii]) %*% solve(V[,,ii]/nk[ii] + Omega[,,ii])
}
IB <- diag(d) - B
mu[,ii] <- rmvnorm(1, B %*% lambda[,ii] + IB %*% xbar, IB %*% V[,,ii]/nk[ii])
}
}
# update V
for(ii in 1:K) {
# don't update if there are no observations
if(nk[ii] > 0) {
if(nk[ii] > 1) {
S <- crossprod(scale(x[I == ii,], center = mu[,ii], scale = FALSE))
} else S <- tcrossprod(x[I == ii,] - mu[,ii])
V[,,ii] <- solve(rWishart(1, df = nk[ii]+nu[ii],
Sigma = solve(S+Psi[,,ii]))[,,1])
}
}
# update p
p <- c(rdirich(1, alpha + nk))
# update I
for(ii in 1:K) {
densK[ii,] <- p[ii]*dmvnorm(x, mu[,ii], V[,,ii])
}
I <- apply(densK, 2, sample, x = 1:K, size = 1, replace = TRUE)
# loglikelihood
if(loglik) {
ll <- sum(log(dnmix(x, mu, V, p)))
}
# store
if(smp > 0) {
mu.iter[,,smp] <- mu
V.iter[,,,smp] <- V
p.iter[,smp] <- p
I.iter[,smp] <- I
if(loglik) {
ll.iter[smp] <- ll
}
}
}
output <- list(mu = mu.iter, V = V.iter, p = p.iter, I = I.iter)
if(loglik) output <- c(output, list(loglik = ll.iter))
output
}
K <- 3
nsamples <- 1e3
system.time({
smp <- nmix.gibbs(x, K = K, nsamples = nsamples,
#prior = list(Omega = replicate(K, 0*diag(d)),
#  nu = rep(d, K),
#  Psi = replicate(K, 0*diag(d)), alpha = rep(5, K)),
#I0 = sample(1:K, size = n, replace = TRUE, prob = exp(1:3)),
loglik = TRUE,
debug = FALSE)
})
require(mclust)
install.packages("mclust")
require(mclust)
md <- me(modelName = "VVV", data = x, z = t(rmultinom(n, 1, exp(3:1))))
md$loglik # value of loglik.obs at mode
par(mfrow = c(d,K), mar = c(4,4.2,1,1))
bayes.mu <- smp$mu
bayes.mu <- bayes.mu[,order(rowMeans(bayes.mu[4,,])),]
freq.mu <- md$parameter$mean
freq.mu <- freq.mu[,order(freq.mu[4,])]
for(ii in 1:d) {
for(jj in 1:K) {
# posterior
hist(bayes.mu[ii,jj,], breaks = 100, freq = FALSE, main = "",
xlab = eval(substitute(expression(mu[a*b]), list(a=ii,b=jj))))
# bayesian point estimate
abline(v = mean(bayes.mu[ii,jj,]), col = "black", lwd = 2)
# frequentist estimate
abline(v = freq.mu[ii,jj], col = "red", lwd = 2)
# true value
abline(v = mu[ii,jj], col = "blue", lwd = 2)
}
}
legend(x = "topleft", legend = expression(mu[true], hat(mu)[EM], hat(mu)[Gibbs]),
col = c("blue", "red", "black"), lwd = 2)
# histograms of probabilities
bayes.p <- smp$p
bayes.p <- bayes.p[order(rowMeans(bayes.p)),]
freq.p <- md$parameters$pro
freq.p <- sort(freq.p)
par(mfrow = c(1,K))
for(ii in 1:K) {
# posterior
hist(bayes.p[ii,], breaks = 100, freq = FALSE, main = "",
xlab = eval(substitute(expression(p[a], list(a=ii)))))
# bayesian point estimate
abline(v = mean(bayes.p[ii,]), col = "black", lwd = 2)
# frequentist estimate
abline(v = freq.p[ii], col = "red", lwd = 2)
# true value
abline(v = p[ii], col = "blue", lwd = 2)
}
legend(x = "topleft", legend = expression(p[true], hat(p)[EM], hat(p)[Gibbs]),
col = c("blue", "red", "black"), lwd = 2)
par(mfrow = c(1,1))
plot(smp$loglik, ylim = range(smp$loglik, md$loglik),
xlab = "Gibbs Sample Number", ylab = expression(l(theta*" | "*X)))
abline(h = md$loglik, col = "red")
par(mfrow = c(d,K), mar = c(4,4.2,2,1))
lag.max <- 200 # maximum number of autocorrelation lags to calculate
for(ii in 1:d) {
for(jj in 1:K) {
acf(smp$mu[ii,jj,], main = "")
title(main = eval(substitute(expression(mu[a*b]), list(a=ii,b=jj))), line = 1)
}
}
pairs(iris[1:4], col = c("red", "blue", "black")[as.numeric(iris$Species)], pch = "+")
pairs(iris[1:4], col = "black", pch = "+")
K <- 3
d <- 4
nsamples <- 1e3
iris.x <- as.matrix(iris[1:d])
iris.I <- as.numeric(iris$Species)
# Gibbs sampler
# could not use the default prior.
N <- 18
d <- 4
dt <- 1/60
X <- matrix(rep(1:N, d), N, d)
X
X - c(0,1,2,3)
X - matrix(c(0,1,2,3),1,4)
N <- 1800
d <- 4
k <- 6
dt <- 1/60
X <- matrix(rep(1:N, k), N, k)
Beta <- matrix(rnorm(k*d), k, d)
install.packages("MCMCpack")
?riwish
require(MCMCpack)
?riwish
riwish(6, matrix(c(1,2,3,5),2,2))
AA = matrix(c(1,2,3,5),2,2)
eigen(AA)
AA = matrix(c(1,2,3,4),2,2)
eigen(AA)
At = tcrossprod(AA)
At
eigen(At)
riwish(5, At)
At = toeplitz(c(1,2,3,4,5))
At
eigen(At)
crossprod(At)
V =  matrix(rnorm(25), 5, 5)
x1 = rnorm(5)
x2 = rnorm(5)
x3 = rnorm(5)
x4 = rnorm(5)
X = cbind(x1,x2,x3,x4)
X
X %*% V %*% t(X)
t(X) %*% V %*% X
x1
x1 %*% V %*% t(x1)
t(x1) %*% V %*% x1
t(x1) %*% V %*% x2
?array
a = 1:6
k = 4
a-k
(a-k) * (a > k)
Theta0 <- list()
Theta0$Lambda <- array(list(), k)
k = 3
Theta0$Lambda <- array(list(), k)
Theta0$Lambda
Theta0$Lambda[[1]]$Psi = 1
Theta0$Lambda[[1]]$Omega = 2
Theta0$Lambda
Xi.comp <- function(X, Ft, Lambda, num){
k <- ncol(Ft)
Xi <- X
ar <- 1:k
for(ii = ar[ar != num]){
Xi <- Xi - Ft[, ii] %*% Lambda[ii, ]
}
Xi
}
Xi.comp <- function(X, Ft, Lambda, num){
k <- ncol(Ft)
Xi <- X
ar <- 1:k
for(ii in ar[ar != num]){
Xi <- Xi - Ft[, ii] %*% Lambda[ii, ]
}
Xi
}
X = matrix(0, 6,3)
Ft = matrix(1, 6, 4)
Lambda = matrix(2, 4, 3)
Xi.comp(X, Ft, Lambda, 1)
Ft[,1]
Ft
Lambda
Lambda[1,]
Xi.comp <- function(X, Ft, Lambda, num){
k <- ncol(Ft)
Xi <- X
ar <- 1:k
for(ii in ar[ar != num]){
Xi <- Xi - t(Ft[, ii]) %*% Lambda[ii, ]
}
Xi
}
Xi.comp(X, Ft, Lambda, 1)
k <- ncol(Ft)
Xi <- X
ar <- 1:k
num = 1
ar[ar != num]
ii = 2
Xi <- Xi - Ft[, ii] %*% Lambda[ii, ]
Xi
Ft[, ii]
Lambda[ii, ]
Ft[, ii] %*% Lambda[ii, ]
t(Ft[, ii]) %*% Lambda[ii, ]
t(Ft[, ii])
is.matrix(Ft[,ii])
crossprod(Ft[, ii], Lambda[ii, ])
Ft[, ii]
Lambda[ii, ]
as.matrix(Ft[, ii]) %*% t(Lambda[ii, ])
Ft[, ii] %*% t(Lambda[ii, ])
tcrossprod(Ft[, ii], Lambda[ii, ])
?tcrossprod
a.b.c <- 1
a.b.c
a = matrix(1, 4, 4)
b = c(1,2,3,4)
a / b
a = matrix(1,5,4)
b
a / b
a %*% diag(1/b)
fdyn.msd <- function(t, alpha, sigma){
tau <- t / sigma
((tau+1)^(2+alpha) + (tau-1)^(2+alpha) - 2*tau^(2+alpha) - 2) / (alpha+1)/(alpha+2)*sigma^alpha
}
fdyn.msd(5, 1, 0.2)
?optimize
??optim
??optimize
n <- 10
d <- 1
Add <- function(x, y){
x + y
}
Add(n + d)
n <- 10
Add(n, d)
a <- 1:5
A <- toeplitz(a)
L1 <- toeplitz(a)
L1[upper.tri(L1)] <- 0
A - tcrossprod(L1)
L2 <- toeplitz(c(0, a[5:2]))
L2[upper.tri(L2)] <- 0
A - tcrossprod(L1) - tcrossprod(L2)
A - tcrossprod(L1) + tcrossprod(L2)
L1
L2
A - crossprod(L1) + crossprod(L2)
L1
L2
L2 <- toeplitz(c(0, a[5:2-1]))
L2[upper.tri(L2)] <- 0
A - crossprod(L1) + crossprod(L2)
a <- 1:5
A <- toeplitz(a)
L1 <- toeplitz(a)
L1[upper.tri(L1)] <- 0
L2 <- toeplitz(c(0, a[-1]))
L2[upper.tri(L2)] <- 0
A - crossprod(L1) + crossprod(L2)
?crossprod
A - tcrossprod(L1) + tcrossprod(L2)
a <- 1:5
A <- toeplitz(a)
L1 <- toeplitz(a)
L1[upper.tri(L1)] <- 0
L1
b <- rnorm(5)
L1 %*% b
t(L1) %*% b
?rev
L1 %*% b
t(L1) %*% rev(b)
L1 %*% b - rev(t(L1) %*% rev(b))
a <- 1:5
A <- toeplitz(a)
L1 <- toeplitz(a)
L1[upper.tri(L1)] <- 0
b <- 6:10
B <- toeplitz(b)
L2 <- toeplitz(b)
L2[upper.tri(L2)] <- 0
L1
L2
L1 %*% L2
fft(fft(a) * fft(b), inverse = T)/5
fft(fft(c(a, rep(0, 5))) * fft(c(b, rep(0, 5))), inverse = T)/10
Re(fft(fft(c(a, rep(0, 5))) * fft(c(b, rep(0, 5))), inverse = T)/10)
round(Re(fft(fft(c(a, rep(0, 5))) * fft(c(b, rep(0, 5))), inverse = T)/10), 2)
a <- 2:6
A <- toeplitz(a)
L1 <- A
L1[upper.tri(L1)] <- 0
L2 <- toeplitz(c(0, a[-1]))
L2[upper.tri(L2)] <- 0
A
crossprod(L1) - crossprod(L2)
A
crossprod(L1) - crossprod(L2) / 2
A
(crossprod(L1) - crossprod(L2)) / 2
A - (crossprod(L1) - crossprod(L2)) / 2
B <- solve(A)
B
phi <- B[1,]
phi
B <- solve(A)
phi <- B[1,]
LL1 <- toeplitz(phi)
LL1[upper.tri(LL1)] <- 0
LL2 <- toeplitz(c(0, rev(phi[-1])))
LL2[upper.tri(LL2)] <- 0
B - (crossprod(LL1) - crossprod(LL2))
B - (crossprod(LL1) - crossprod(LL2))/phi[1]
require(Toeplitz)
tr <- function(X) sum(diag(X)) # matrix trace
n <- 6
acf <- exp(-(1:n)^2/102)*102
T1 <- new(Toeplitz, n)
T1$acfInput(acf)
acf2 <- rnorm(n)
acf3 <- rnorm(n)
traceDerv.R <- function(acf, acf2, acf3, debug = F){
if(debug) browser()
T1 <- toeplitz(acf)
T2 <- toeplitz(acf2)
T3 <- toeplitz(acf3)
n <- length(acf)
sT1 <- solve(T1)
phi <- matrix(sT1[,1], n, 1)
phi2 <- - sT1 %*% T2 %*% phi
phi <- as.vector(phi)
phi2 <- as.vector(phi2)
L1.phi2 <- toeplitz(phi2)
L1.phi2[upper.tri(L1.phi2)] <- 0
L1.phi <- toeplitz(phi)
L1.phi[upper.tri(L1.phi)] <- 0
L2.phi2 <- toeplitz(c(0, rev(phi2[-1])))
L2.phi2[upper.tri(L2.phi2)] <- 0
L2.phi <- toeplitz(c(0, rev(phi[-1])))
L2.phi[upper.tri(L2.phi)] <- 0
trace <- - phi2[1] * tr(sT1 %*% T3)
trace <- trace + 2 * tr(L1.phi2 %*% t(L1.phi) %*% T3)
# knowing that T3 = 1/acf3[1] * (L3 L3' - L4 L4')
L3 <- toeplitz(acf3)
L3[upper.tri(L3)] <- 0
L4 <- toeplitz(c(0, acf3[-1]))
L4[upper.tri(L4)] <- 0
trace <- trace - 2 * tr(L2.phi2 %*% t(L2.phi) %*% T3)
trace / phi[1]
}
T1$tracederv(acf2, acf3) - traceDerv.R(acf, acf2, acf3)
tr <- function(X) sum(diag(X)) # matrix trace
a <- rnorm(9)
b <- rnorm(9)
A <- matrix(a, 3, 3)
B <- matrix(b, 3, 3)
tr(A %*% t(B))
sum(A)
sum(A * B)
a = array(1, dim = c(4,3,2))
a
a[, 1, 1]
is.vector(a[,1,1])
require(Toeplitz)
tr <- function(X) sum(diag(X)) # matrix trace
n <- 46
d <- 4
acf <- exp(-(1:n)^2/102)*102
x <- matrix(rnorm(n*d), n, d)
y <- matrix(rnorm(n*d), n, d)
z <- matrix(rnorm(n*d), n, d)
T1 <- new(Toeplitz, n)
T1$DimCheck()
## run the function
T1$AcfInput(acf)
## InverseProd part
msg <- T1$Mult(x)
range(msg - toeplitz(acf)%*%x)
msg <- T1$Solve(y)
msg1 <- T1$Solve(x)
msg2 <- T1$Solve(z)
range(toeplitz(acf) %*% msg - y)
# determinant part
T1$Det() - log(det(toeplitz(acf)))
# determinant part
acf2 <- exp(-(1:n)^2/12)*12
T1$AcfInput(acf2)
T1$Det() - log(det(toeplitz(acf2)))
# traceProd test ----------------------------------------------------------
require(Toeplitz)
tr <- function(X) sum(diag(X)) # matrix trace
n <- 46
acf <- exp(-(1:n)^2/102)*102
T1 <- new(Toeplitz, n)
T1$AcfInput(acf)
acf2 <- rnorm(n)
acf3 <- rnorm(n)
T1$TraceProd(acf2) - tr(solve(toeplitz(acf)) %*% toeplitz(acf2))
T1$TraceProd(acf3) - tr(solve(toeplitz(acf)) %*% toeplitz(acf3))
## delete
rm(T1)
# traceDerv test ----------------------------------------------------------
xv <- rnorm(n)
T1 <- new(Toeplitz, n)
## dimension check
T1$DimCheck()
## run the function
T1$AcfInput(acf)
msgv <- T1$Solve(xv)
setwd("D:/GitHub/SuperGauss/Toeplitz")
require(Rcpp)
require(devtools)
compileAttributes() # regenerates Rcpp interface (i.e., RcppExports)
#document()
install()
require(Toeplitz)
# Toeplitz class
tr <- function(X) sum(diag(X)) # matrix trace
n <- 46
d <- 4
acf <- exp(-(1:n)^2/102)*102
x <- matrix(rnorm(n*d), n, d)
y <- matrix(rnorm(n*d), n, d)
z <- matrix(rnorm(n*d), n, d)
xv <- rnorm(n)
T1 <- new(Toeplitz, n)
## dimension check
T1$DimCheck()
## run the function
T1$AcfInput(acf)
## InverseProd part
msg <- T1$Mult(x)
range(msg - toeplitz(acf)%*%x)
msg <- T1$Solve(y)
msg1 <- T1$Solve(x)
msg2 <- T1$Solve(z)
range(toeplitz(acf) %*% msg - y)
# overload for vector
msgv <- T1$SolveVec(xv)
range(toeplitz(acf) %*% msgv - xv)
# determinant part
T1$Det() - log(det(toeplitz(acf)))
msg <- T1$Mult(x)
msxv <- T1$MultVec(xv)
range(msg - toeplitz(acf) %*% x)
range(msxv - toeplitz(acf) %*% xv)
a = matrix(4,3,1)
a
b = matrix(5, 3, 2)
b - a
b[, 1] = b[, 1] - a
b
b = matrix(5, 3, 2)
b
b = b - as.vector(a)
is.matrix(b)
b
a
vector(a)
?vector
?is.matrix
a
b
is.matrix(a)
a[,1]
is.matrix(a[,1])
