<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SuperGauss: GSchurN Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SuperGauss
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_g_schur_n-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GSchurN Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_g_schur_8h_source.html">GSchur.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf53087c8381490aa8d41b8693c1ada7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#adf53087c8381490aa8d41b8693c1ada7">GSchurN</a> (int N, int bmod)</td></tr>
<tr class="memdesc:adf53087c8381490aa8d41b8693c1ada7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#adf53087c8381490aa8d41b8693c1ada7">More...</a><br /></td></tr>
<tr class="separator:adf53087c8381490aa8d41b8693c1ada7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38671cfad33b0b8523503105ae7b7196"><td class="memItemLeft" align="right" valign="top"><a id="a38671cfad33b0b8523503105ae7b7196"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a38671cfad33b0b8523503105ae7b7196">~GSchurN</a> ()</td></tr>
<tr class="memdesc:a38671cfad33b0b8523503105ae7b7196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a38671cfad33b0b8523503105ae7b7196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da15535aa130e12879798c854c8e7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a0da15535aa130e12879798c854c8e7af">compute</a> (double *delta, double &amp;ldV, const double *acf)</td></tr>
<tr class="memdesc:a0da15535aa130e12879798c854c8e7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the Generalized Schur algorithm on the input data.  <a href="#a0da15535aa130e12879798c854c8e7af">More...</a><br /></td></tr>
<tr class="separator:a0da15535aa130e12879798c854c8e7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a44601c55cbb867f71e22218be6673251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a44601c55cbb867f71e22218be6673251">compute_nn</a> (<a class="el" href="struct_g_schur2_k.html">GSchur2K</a> *gsr, int n1, int n2)</td></tr>
<tr class="memdesc:a44601c55cbb867f71e22218be6673251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <code>alphan</code> and <code>betan</code> from <code>alpha0</code>, <code>beta0</code>, <code>eta0</code>, and <code>xi0</code>.  <a href="#a44601c55cbb867f71e22218be6673251">More...</a><br /></td></tr>
<tr class="separator:a44601c55cbb867f71e22218be6673251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af563a79ffd3a13c0c1617702e66d2e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#af563a79ffd3a13c0c1617702e66d2e25">compute_2n</a> (<a class="el" href="struct_g_schur2_k.html">GSchur2K</a> *gsr, int n)</td></tr>
<tr class="memdesc:af563a79ffd3a13c0c1617702e66d2e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <code>eta2n</code> and <code>xi2n</code> from <code>etan</code> and <code>xin</code>.  <a href="#af563a79ffd3a13c0c1617702e66d2e25">More...</a><br /></td></tr>
<tr class="separator:af563a79ffd3a13c0c1617702e66d2e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a43b70b57d14e0e7b4370e713a8bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a60a43b70b57d14e0e7b4370e713a8bb8">prog_step</a> (const double *alpha0, const double *beta0, int n)</td></tr>
<tr class="memdesc:a60a43b70b57d14e0e7b4370e713a8bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progressive Schur algorithm.  <a href="#a60a43b70b57d14e0e7b4370e713a8bb8">More...</a><br /></td></tr>
<tr class="separator:a60a43b70b57d14e0e7b4370e713a8bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c46cd1f382c48f7156b153fdbb4e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a64c46cd1f382c48f7156b153fdbb4e8d">recur_step</a> (const double *alpha0, const double *beta0, int si, int layer)</td></tr>
<tr class="memdesc:a64c46cd1f382c48f7156b153fdbb4e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized Schur algorithm.  <a href="#a64c46cd1f382c48f7156b153fdbb4e8d">More...</a><br /></td></tr>
<tr class="separator:a64c46cd1f382c48f7156b153fdbb4e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4349b17e2d682a045f98cf946b3561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a0a4349b17e2d682a045f98cf946b3561">merge_step</a> ()</td></tr>
<tr class="memdesc:a0a4349b17e2d682a045f98cf946b3561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge pieces of Schur algorithm contained in <code>gsb_</code>.  <a href="#a0a4349b17e2d682a045f98cf946b3561">More...</a><br /></td></tr>
<tr class="separator:a0a4349b17e2d682a045f98cf946b3561"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a62b76086dc42681d4f0c0377916cdfd6"><td class="memItemLeft" align="right" valign="top"><a id="a62b76086dc42681d4f0c0377916cdfd6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a62b76086dc42681d4f0c0377916cdfd6">N_</a></td></tr>
<tr class="memdesc:a62b76086dc42681d4f0c0377916cdfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of input vector. <br /></td></tr>
<tr class="separator:a62b76086dc42681d4f0c0377916cdfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3145c5bca0f220ef449efabb2c1a4"><td class="memItemLeft" align="right" valign="top"><a id="a33b3145c5bca0f220ef449efabb2c1a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a33b3145c5bca0f220ef449efabb2c1a4">bmod_</a></td></tr>
<tr class="memdesc:a33b3145c5bca0f220ef449efabb2c1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer giving binary modulus. Binary pieces of size smaller than <code>bmod_</code> are computed using PSchur algorithm. <br /></td></tr>
<tr class="separator:a33b3145c5bca0f220ef449efabb2c1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a945fcf97d0a454926b63ad727473dd"><td class="memItemLeft" align="right" valign="top"><a id="a4a945fcf97d0a454926b63ad727473dd"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a4a945fcf97d0a454926b63ad727473dd">alpha_</a></td></tr>
<tr class="memdesc:a4a945fcf97d0a454926b63ad727473dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">First input polynomial as a function of <code>acf</code>. <br /></td></tr>
<tr class="separator:a4a945fcf97d0a454926b63ad727473dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1842f8c8f3381cb5a733f836fffe7c96"><td class="memItemLeft" align="right" valign="top"><a id="a1842f8c8f3381cb5a733f836fffe7c96"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a1842f8c8f3381cb5a733f836fffe7c96">beta_</a></td></tr>
<tr class="memdesc:a1842f8c8f3381cb5a733f836fffe7c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second input polynomial as a function of <code>acf</code>. <br /></td></tr>
<tr class="separator:a1842f8c8f3381cb5a733f836fffe7c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a512cc5348f85dc3690da133907f210"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a3a512cc5348f85dc3690da133907f210">sbin_</a></td></tr>
<tr class="separator:a3a512cc5348f85dc3690da133907f210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcc1f1a42a85e9dc32df8ff626e3438"><td class="memItemLeft" align="right" valign="top"><a id="a5fcc1f1a42a85e9dc32df8ff626e3438"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a5fcc1f1a42a85e9dc32df8ff626e3438">nbin_</a></td></tr>
<tr class="memdesc:a5fcc1f1a42a85e9dc32df8ff626e3438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of s. <br /></td></tr>
<tr class="separator:a5fcc1f1a42a85e9dc32df8ff626e3438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0606d5eb870ad7f3856b6c048c503"><td class="memItemLeft" align="right" valign="top"><a id="ad2d0606d5eb870ad7f3856b6c048c503"></a>
<a class="el" href="struct_g_schur2_k.html">GSchur2K</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#ad2d0606d5eb870ad7f3856b6c048c503">gsb_</a></td></tr>
<tr class="memdesc:ad2d0606d5eb870ad7f3856b6c048c503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory allocation for the binary pieces. There are <code>sbin_size()</code> pieces, each of size <code>sbin_[i]</code>. <br /></td></tr>
<tr class="separator:ad2d0606d5eb870ad7f3856b6c048c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d4825337c586493b24572c1bbdbf0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_g_schur2_k.html">GSchur2K</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_schur_n.html#a25d4825337c586493b24572c1bbdbf0f">gsm_</a></td></tr>
<tr class="separator:a25d4825337c586493b24572c1bbdbf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generalized Schur Algorithm for arbitrary size N.</p>
<p>Given a symmetric positive-definite <code>N x N</code> <a class="el" href="class_toeplitz.html">Toeplitz</a> matrix <code>Tz</code> with first row/column <code>acf</code>, calculates <code>delta</code>, the first row/column of <code>Tz^{-1}</code> and <code>log(det(Tz))</code>. This is done using a modified version of the "superfast" <code>O(N log^2(N))</code> algorithm of Ammar &amp; Gragg (1988) which consists of the following steps:</p>
<ol type="1">
<li>Decompose <code>N</code> into a vectors <code>s = (s_1, ..., s_k)</code>, where each <code>s_i</code> is a power of 2 and <code>sum(s) = N</code>.</li>
<li>Divide the problem into pieces of size <code>s_i</code>, and solve each using the recursive algorithm of Ammar &amp; Gragg (1988). This is done with the private method <code><a class="el" href="class_g_schur_n.html#a64c46cd1f382c48f7156b153fdbb4e8d" title="Generalized Schur algorithm.">recur_step()</a></code>.</li>
<li>Merge the pieces of size <code>s_i</code> in order to solve the original problem. This is done using the private method <code><a class="el" href="class_g_schur_n.html#a0a4349b17e2d682a045f98cf946b3561" title="Merge pieces of Schur algorithm contained in gsb_.">merge_step()</a></code>. <p class="formulaDsp">
\[ T_{0,N} = T_{0, r} \circ T_{r, s_1} \circ ... \circ T_{..., s_m}. \]
</p>
 </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adf53087c8381490aa8d41b8693c1ada7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf53087c8381490aa8d41b8693c1ada7">&#9670;&nbsp;</a></span>GSchurN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GSchurN::GSchurN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bmod</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Size of <a class="el" href="class_toeplitz.html">Toeplitz</a> matrix (input to GSchur algorithm is <code>N-1</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bmod</td><td>Binary modulus (integer). </td></tr>
  </table>
  </dd>
</dl>
<p>sbin_ = (s_1, s_2, ..., s_k) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0da15535aa130e12879798c854c8e7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da15535aa130e12879798c854c8e7af">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GSchurN::compute </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ldV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>acf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the Generalized Schur algorithm on the input data. </p>
<p>First generates the input polynomials <code>alpha0</code> and <code>beta0</code> from the first column <code>acf</code> of a symmetric positive-definite <a class="el" href="class_toeplitz.html">Toeplitz</a> matrix <code>Tz = <a class="el" href="class_toeplitz.html">Toeplitz(acf)</a></code>, then applies the Generalized Schur algorithm to each piece in the binary-module representation, and finally merges these pieces to produce the first column of <code>Tz^{-1}</code> and calculate the log-determinant of <code>Tz</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">delta</td><td>The first column of <code>Tz^{-1}</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ldV</td><td>The log-determinant of <code>Tz</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acf</td><td>The first column of <code>Tz</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af563a79ffd3a13c0c1617702e66d2e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af563a79ffd3a13c0c1617702e66d2e25">&#9670;&nbsp;</a></span>compute_2n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GSchurN::compute_2n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_schur2_k.html">GSchur2K</a> *&#160;</td>
          <td class="paramname"><em>gsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute <code>eta2n</code> and <code>xi2n</code> from <code>etan</code> and <code>xin</code>. </p>
<p>Given polynomials <code>etan(x)</code>, <code>xin(x)</code>, <code>eta0(x)</code>, and <code>xi0(x)</code> each represented by a double array <code>etan</code>, <code>xin</code>, etc., compute polynomials <code>eta2n(x)</code> and <code>xi2n(x)</code> defined as</p>
<div class="fragment"><div class="line">eta2n(x) = tilde(xi0(x)) * xin(x) + eta0(x) * etan(x),</div><div class="line">xi2n(x) = tilde(eta0(x)) * xin(x) + xi0(x) * etan(x).</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gsr</td><td>Pointer to the GSchur storage object containing <code>etan</code>, <code>xin</code>, etc. Output is stored in <code>gsr-&gt;eta2n</code> and <code>grs-&gt;xin</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of each polynomial <code>etan</code>, <code>xin</code>, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44601c55cbb867f71e22218be6673251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44601c55cbb867f71e22218be6673251">&#9670;&nbsp;</a></span>compute_nn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GSchurN::compute_nn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_schur2_k.html">GSchur2K</a> *&#160;</td>
          <td class="paramname"><em>gsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute <code>alphan</code> and <code>betan</code> from <code>alpha0</code>, <code>beta0</code>, <code>eta0</code>, and <code>xi0</code>. </p>
<p>Given polynomials <code>alpha0(x)</code>, <code>beta0(x)</code>, <code>eta0(x)</code>, and <code>xi0(x)</code> each represented by a double array <code>alpha0</code>, <code>beta0</code>, etc., compute polynomials <code>alphan(x)</code> and <code>betan(x)</code> defined as</p>
<div class="fragment"><div class="line">alphan(x) = (alpha0(x) * eta0(x) - beta0(x) * xi0(x)) / x^n,</div><div class="line">betan(x) = (beta0(x) * tilde(eta0(x)) - alpha0(x) * tilde(xi0(x))) / x^n,</div></div><!-- fragment --><p> where <code>tilde(poly(x)) = x^deg(poly) * poly(1/x)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>By negating the odd parts of the complex conjugate of <code>fft(eta0, 0, 0, ..., 0)</code>, we can directly get <code>fft(0, rev(eta0), 0, ..., 0)</code>. However, this only works when the amount of zero-padding is also <code>n</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gsr</td><td>Pointer to the GSchur storage object containing <code>alpha0</code>, <code>beta0</code>, etc. Output is stored in <code>gsr-&gt;alphan</code> and <code>grs-&gt;betan</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of each polynomial <code>alpha0</code> and <code>beta0</code>, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npad</td><td>Integer amount of zero-padding. The size of each FFT/iFFT is <code>n + npad</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a4349b17e2d682a045f98cf946b3561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4349b17e2d682a045f98cf946b3561">&#9670;&nbsp;</a></span>merge_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GSchurN::merge_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge pieces of Schur algorithm contained in <code>gsb_</code>. </p>
<p>The final output of the algorithm is stored in <code>gsm_[0]-&gt;eta2n</code>, <code>gsm_[0]-&gt;xi2n</code>, and <code>gsm_[0]-&gt;gamma</code>. </p>

</div>
</div>
<a id="a60a43b70b57d14e0e7b4370e713a8bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a43b70b57d14e0e7b4370e713a8bb8">&#9670;&nbsp;</a></span>prog_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GSchurN::prog_step </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>alpha0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>beta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Progressive Schur algorithm. </p>
<p>The Progressive Schur (PSchur) algorithm is used for pieces of size less than or equal to the "binary modulus" <code>bmod_</code>. This is because it is faster than the recursive Generalized Schur (GSchur) algorithm for small sizes. The output of either algorithm is the same, so both can be merged as is done in <code><a class="el" href="class_g_schur_n.html#a64c46cd1f382c48f7156b153fdbb4e8d" title="Generalized Schur algorithm.">recur_step()</a></code> and <code><a class="el" href="class_g_schur_n.html#a0a4349b17e2d682a045f98cf946b3561" title="Merge pieces of Schur algorithm contained in gsb_.">merge_step()</a></code>. Because of the construction of the GSchur algorithm, PSchur always uses memory in <code>gsb_[0]</code>. The final output of the algorithm is stored in <code>gsb_[0]-&gt;eta2n</code>, <code>gsb_[0]-&gt;xi2n</code>, and <code>gsb_[0]-&gt;gamma</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha0</td><td>First input real vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta0</td><td>Second input real vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of each input (integer). This is either <code>sbin_[0]</code> or <code>bmod_</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64c46cd1f382c48f7156b153fdbb4e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c46cd1f382c48f7156b153fdbb4e8d">&#9670;&nbsp;</a></span>recur_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GSchurN::recur_step </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>alpha0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>beta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalized Schur algorithm. </p>
<p>The Generalized Schur (GSchur) algorithm is a recursive doubling procedure. It has the same output as PSchur, and shares the same first three inputs as <code><a class="el" href="class_g_schur_n.html#a60a43b70b57d14e0e7b4370e713a8bb8" title="Progressive Schur algorithm.">prog_step()</a></code>. However, it stores the output in <code>gsb_[layer]</code> by recursively building up the pieces from <code>gsb_[0]</code>. The final output of the algorithm is stored in <code>gsb_[layer]-&gt;eta2n</code>, <code>gsb_[layer]-&gt;xi2n</code>, and <code>gsb_[layer]-&gt;gamma</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha0</td><td>First input real vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta0</td><td>Second input real vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of each input (integer). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>In which element of <code>gsb_</code> array to store computation (integer). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a25d4825337c586493b24572c1bbdbf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d4825337c586493b24572c1bbdbf0f">&#9670;&nbsp;</a></span>gsm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_g_schur2_k.html">GSchur2K</a>** GSchurN::gsm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory allocation for merging the pieces. </p>

</div>
</div>
<a id="a3a512cc5348f85dc3690da133907f210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a512cc5348f85dc3690da133907f210">&#9670;&nbsp;</a></span>sbin_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; GSchurN::sbin_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector that records the binary decomposition of <code>N</code>. \(s = {2^{k_0} \times b, 2^{k_1} \times b, ..., &lt; 2^{k_T} \times b, r}\). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>inst/include/<a class="el" href="_g_schur_8h_source.html">GSchur.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
